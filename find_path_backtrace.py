"""
回溯法：
    下面考虑迷宫问题的回溯法实现，这种算法在工作中执行两种基本操作，前进和后退
    前进：
        条件：当前位置存在尚未探查的四邻位置
        操作：选定下一位置并向前探查。如果还存在其他可能未探查的分支，就记录相关信息，以便将 来使用
    如果找到出口，则成功结束
    后退：
        条件：遇到死路不存在尚未探查的四邻位置
        操作：退回最近记录的那个分支，检查那里是否还存在未探查分支。
             如果有，就取一个未探查邻位置，作为当前位置并前进，没有就将其删除并继续回溯
    已穷尽所有可能：不能找到出口以失败结束

回溯法是一种很重要的算法设计模式，他通常是使用一个栈作为辅助结构，保存工作中遇到的回溯点，以便后面考虑其他可能性时使用

迷宫问题的回溯法求解

入口start相关信息（位置和尚未探索方向）入栈：
while 栈不空：
    弹出栈顶元素作为当前位置并继续搜索
    while 当前位置存在未探查方向：
        求出下一探查位置nextp
        if nextp 是出口：
            输出路径并结束
        if nextp 尚未探查：
            将当前位置和nextp顺序入栈并退出内层循环
"""
from list_stack import ListStack   # 导入顺序栈


# 定义迷宫
maze = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],
    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]

# 为了能方便的计算相邻位置，这里定义一个二元组（二元序对）的表，其元素是从位置（i，j）得到四邻位置应该加的数对,对于任何位置，给他加上dir[0],dir[1],dir[2],dir[3],就分别得到了东南西北的四个相邻位置
dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]

# 给迷宫maze的位置pos标2表示到过了，其中参数pos为二元序对，形式为（i，j）,maze表示迷宫
def mark(maze, pos):
    maze[pos[0]][pos[1]] = 2

# 检查迷宫maze的位置pos是否可行
def possible(maze, pos):
    return maze[pos[0]][pos[1]] == 0


# 定义输出路径
def print_path(end, pos, stack):
    print(end,end=' ')
    print(end=' ')
    while True:
        print(stack.pop()[0], end=' ')


# 定义回溯法求解迷宫,maze未迷宫，start未开始位置，end未结束位置
def find_path_backtrace(maze, start, end):
    if start == end:    # 如果入口就是出口，直接找到，搜索结束，打印出来就行
        print(start)
        return

    st = ListStack()   # 实例化栈
    mark(maze, start)  # 压入栈的时候先标记他，这样就保证了任何位置不会被压入两次，避免重复
    st.push((start, 0))  # 入口和方向0的序对入栈

    while not st.is_empty():    # 回退
        pos, nxt = st.pop()   # 取栈顶以及他的探查方向
        for i in range(nxt, 4):
            nextp = (pos[0]+dirs[i][0], pos[1]+dirs[i][1])  # 得到下一位置
            if nextp == end:  # 到达出口，打印路径
                print_path(end, pos, st)
                return
            if possible(maze, nextp):   # 遇到未探查的新位置
                st.push((pos, i+1))   # 原位置和下一方向入栈
                mark(maze, nextp)
                st.push((nextp, 0))   # 新位置入栈
                break   # 退出内层循环，下次迭代将以新栈顶未当前位置继续
    print('对不起！找不到路径...')   # 找不到路径


if __name__ == '__main__':
    start = (1, 1)
    end = (10, 12)
    find_path_backtrace(maze, start, end)
