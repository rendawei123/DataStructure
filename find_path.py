"""
迷宫问题：
对于迷宫问题，一般是给定了一个迷宫图，包括图中的一个入口点和一个出口点，要求在图中找到一条从入口到出口的路径，各种具体的迷宫可能具有不同的表面结构，给出的迷宫各种个样，但问题实质都差不多，是一种找路径问题

问题分析：
    1、从迷宫的入口开始检查，这是初始的当前位置；
    2、如果当前位置就是出口，已经找到出口，问题已解决；
    3、如果从当前位置已无路可走，当前正在进行的探查失败，需要按一定位置另行继续搜索，这是迷宫问题搜索的技术和策略问题，下面讨论
    4、从可行方向中取出一个向前进一步，从那里继续探索通往出口的路径
解法分析
    我们把迷宫可以直接印射二维的0／1矩阵，很容易在计算机中表示

"""
# 定义迷宫，墙用1表示，通道用0表示
maze = [
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
[1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1],
[1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1],
[1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
[1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1],
[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
[1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
[1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
[1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1],
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]

# 为了能方便的计算相邻位置，这里定义一个二元组（二元序对）的表，其元素是从位置（i，j）得到四邻位置应该加的数对,对于任何位置，给他加上dir[0],dir[1],dir[2],dir[3],就分别得到了东南西北的四个相邻位置
dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]

# 给迷宫maze的位置pos标2表示到过了，其中参数pos为二元序对，形式为（i，j）,maze表示迷宫
def mark(maze, pos):
    maze[pos[0]][pos[1]] = 2

# 检查迷宫maze的位置pos是否可行
def possible(maze, pos):
    return maze[pos[0]][pos[1]] == 0
